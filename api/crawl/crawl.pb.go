// Code generated by protoc-gen-go. DO NOT EDIT.
// source: crawl.proto

package crawl

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type URLRequestCommand int32

const (
	// URLs in STOPPED, NONE, or DONE may be started.
	URLRequest_START URLRequestCommand = 0
	// URLs in CRAWLING, STOPPED, or DONE may be stopped.
	URLRequest_STOP URLRequestCommand = 1
	// URLs in any state may be checked.
	URLRequest_CHECK URLRequestCommand = 2
)

var URLRequestCommand_name = map[int32]string{
	0: "START",
	1: "STOP",
	2: "CHECK",
}
var URLRequestCommand_value = map[string]int32{
	"START": 0,
	"STOP":  1,
	"CHECK": 2,
}

func (x URLRequestCommand) String() string {
	return proto.EnumName(URLRequestCommand_name, int32(x))
}
func (URLRequestCommand) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_crawl_9196b71f7348a41c, []int{0, 0}
}

type URLState_Status int32

const (
	URLState_STOPPED URLState_Status = 0
	// START for a STOPPED URL resumes the crawl.
	// STOP for a STOPPED URL does nothing.
	URLState_RUNNING URLState_Status = 1
	// Once it completes the crawl, it switches
	// the URL's state to DONE. START for a
	// CRAWLING URL is a no-op. STOP for a CRAWLING
	// URL saves the URL's state and sets it to STOPPED.
	URLState_DONE URLState_Status = 2
	// If the crawler receives a START for a DONE
	// URL, it discards the crawl history and
	// crawls it again. If it receives a STOP, it
	// does nothing.
	URLState_UNKNOWN URLState_Status = 3
	// This is a meta-state; URLs never crawled
	// are not recorded in the client to avoid a
	// possible DoS from a clog of never-crawled URLs.
	// Only returned for a STOP.
	URLState_FAILED URLState_Status = 4
)

var URLState_Status_name = map[int32]string{
	0: "STOPPED",
	1: "RUNNING",
	2: "DONE",
	3: "UNKNOWN",
	4: "FAILED",
}
var URLState_Status_value = map[string]int32{
	"STOPPED": 0,
	"RUNNING": 1,
	"DONE":    2,
	"UNKNOWN": 3,
	"FAILED":  4,
}

func (x URLState_Status) String() string {
	return proto.EnumName(URLState_Status_name, int32(x))
}
func (URLState_Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_crawl_9196b71f7348a41c, []int{1, 0}
}

// URLRequest defines the outgoing request.
// We can provide a URL and the state we want the client
// to put it in.
type URLRequest struct {
	URL                  string            `protobuf:"bytes,1,opt,name=URL,proto3" json:"URL,omitempty"`
	State                URLRequestCommand `protobuf:"varint,2,opt,name=state,proto3,enum=crawl.URLRequestCommand" json:"state,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *URLRequest) Reset()         { *m = URLRequest{} }
func (m *URLRequest) String() string { return proto.CompactTextString(m) }
func (*URLRequest) ProtoMessage()    {}
func (*URLRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_crawl_9196b71f7348a41c, []int{0}
}
func (m *URLRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_URLRequest.Unmarshal(m, b)
}
func (m *URLRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_URLRequest.Marshal(b, m, deterministic)
}
func (dst *URLRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_URLRequest.Merge(dst, src)
}
func (m *URLRequest) XXX_Size() int {
	return xxx_messageInfo_URLRequest.Size(m)
}
func (m *URLRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_URLRequest.DiscardUnknown(m)
}

var xxx_messageInfo_URLRequest proto.InternalMessageInfo

func (m *URLRequest) GetURL() string {
	if m != nil {
		return m.URL
	}
	return ""
}

func (m *URLRequest) GetState() URLRequestCommand {
	if m != nil {
		return m.State
	}
	return URLRequest_START
}

// URLState reports the crawl status ONLY of a URL.
type URLState struct {
	Status               URLState_Status `protobuf:"varint,1,opt,name=status,proto3,enum=crawl.URLState_Status" json:"status,omitempty"`
	Message              string          `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *URLState) Reset()         { *m = URLState{} }
func (m *URLState) String() string { return proto.CompactTextString(m) }
func (*URLState) ProtoMessage()    {}
func (*URLState) Descriptor() ([]byte, []int) {
	return fileDescriptor_crawl_9196b71f7348a41c, []int{1}
}
func (m *URLState) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_URLState.Unmarshal(m, b)
}
func (m *URLState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_URLState.Marshal(b, m, deterministic)
}
func (dst *URLState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_URLState.Merge(dst, src)
}
func (m *URLState) XXX_Size() int {
	return xxx_messageInfo_URLState.Size(m)
}
func (m *URLState) XXX_DiscardUnknown() {
	xxx_messageInfo_URLState.DiscardUnknown(m)
}

var xxx_messageInfo_URLState proto.InternalMessageInfo

func (m *URLState) GetStatus() URLState_Status {
	if m != nil {
		return m.Status
	}
	return URLState_STOPPED
}

func (m *URLState) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

// SiteNode is returned in response to a STATUS request.
// It returns a tree of sitenodes found under the current
// URL (which may recursively contain more SiteNodes).
// If no URL is supplied, all the SiteNodes the crawler
// knows about are returned as the children of a SiteNode
// with the siteURL "all://".
type SiteNode struct {
	SiteURL              string   `protobuf:"bytes,1,opt,name=siteURL,proto3" json:"siteURL,omitempty"`
	TreeString           string   `protobuf:"bytes,2,opt,name=treeString,proto3" json:"treeString,omitempty"`
	Status               string   `protobuf:"bytes,3,opt,name=status,proto3" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SiteNode) Reset()         { *m = SiteNode{} }
func (m *SiteNode) String() string { return proto.CompactTextString(m) }
func (*SiteNode) ProtoMessage()    {}
func (*SiteNode) Descriptor() ([]byte, []int) {
	return fileDescriptor_crawl_9196b71f7348a41c, []int{2}
}
func (m *SiteNode) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SiteNode.Unmarshal(m, b)
}
func (m *SiteNode) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SiteNode.Marshal(b, m, deterministic)
}
func (dst *SiteNode) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SiteNode.Merge(dst, src)
}
func (m *SiteNode) XXX_Size() int {
	return xxx_messageInfo_SiteNode.Size(m)
}
func (m *SiteNode) XXX_DiscardUnknown() {
	xxx_messageInfo_SiteNode.DiscardUnknown(m)
}

var xxx_messageInfo_SiteNode proto.InternalMessageInfo

func (m *SiteNode) GetSiteURL() string {
	if m != nil {
		return m.SiteURL
	}
	return ""
}

func (m *SiteNode) GetTreeString() string {
	if m != nil {
		return m.TreeString
	}
	return ""
}

func (m *SiteNode) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func init() {
	proto.RegisterType((*URLRequest)(nil), "crawl.URLRequest")
	proto.RegisterType((*URLState)(nil), "crawl.URLState")
	proto.RegisterType((*SiteNode)(nil), "crawl.SiteNode")
	proto.RegisterEnum("crawl.URLRequestCommand", URLRequestCommand_name, URLRequestCommand_value)
	proto.RegisterEnum("crawl.URLState_Status", URLState_Status_name, URLState_Status_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// CrawlClient is the client API for Crawl service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type CrawlClient interface {
	// Because we're calling the client from our CLI, we
	// want the CrawlSite API to make a single request
	// and wait for the response. This API lets us start,
	// stop, or check the status of a URL
	CrawlSite(ctx context.Context, in *URLRequest, opts ...grpc.CallOption) (*URLState, error)
	// Checks the current status of a crawl and returns
	// the tree as it stands.
	CrawlResult(ctx context.Context, in *URLRequest, opts ...grpc.CallOption) (*SiteNode, error)
}

type crawlClient struct {
	cc *grpc.ClientConn
}

func NewCrawlClient(cc *grpc.ClientConn) CrawlClient {
	return &crawlClient{cc}
}

func (c *crawlClient) CrawlSite(ctx context.Context, in *URLRequest, opts ...grpc.CallOption) (*URLState, error) {
	out := new(URLState)
	err := c.cc.Invoke(ctx, "/crawl.Crawl/CrawlSite", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *crawlClient) CrawlResult(ctx context.Context, in *URLRequest, opts ...grpc.CallOption) (*SiteNode, error) {
	out := new(SiteNode)
	err := c.cc.Invoke(ctx, "/crawl.Crawl/CrawlResult", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CrawlServer is the server API for Crawl service.
type CrawlServer interface {
	// Because we're calling the client from our CLI, we
	// want the CrawlSite API to make a single request
	// and wait for the response. This API lets us start,
	// stop, or check the status of a URL
	CrawlSite(context.Context, *URLRequest) (*URLState, error)
	// Checks the current status of a crawl and returns
	// the tree as it stands.
	CrawlResult(context.Context, *URLRequest) (*SiteNode, error)
}

func RegisterCrawlServer(s *grpc.Server, srv CrawlServer) {
	s.RegisterService(&_Crawl_serviceDesc, srv)
}

func _Crawl_CrawlSite_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(URLRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CrawlServer).CrawlSite(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crawl.Crawl/CrawlSite",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CrawlServer).CrawlSite(ctx, req.(*URLRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crawl_CrawlResult_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(URLRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CrawlServer).CrawlResult(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crawl.Crawl/CrawlResult",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CrawlServer).CrawlResult(ctx, req.(*URLRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Crawl_serviceDesc = grpc.ServiceDesc{
	ServiceName: "crawl.Crawl",
	HandlerType: (*CrawlServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CrawlSite",
			Handler:    _Crawl_CrawlSite_Handler,
		},
		{
			MethodName: "CrawlResult",
			Handler:    _Crawl_CrawlResult_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "crawl.proto",
}

func init() { proto.RegisterFile("crawl.proto", fileDescriptor_crawl_9196b71f7348a41c) }

var fileDescriptor_crawl_9196b71f7348a41c = []byte{
	// 330 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x51, 0xc1, 0x4e, 0xc2, 0x40,
	0x10, 0x6d, 0x81, 0x16, 0x3a, 0x24, 0xb8, 0xce, 0x81, 0xa0, 0x07, 0x43, 0xf6, 0x84, 0x97, 0x1a,
	0xe1, 0x0b, 0x08, 0x54, 0x25, 0xd4, 0x85, 0xec, 0xd2, 0x78, 0xf1, 0x52, 0x61, 0x43, 0x48, 0x80,
	0x6a, 0x77, 0x89, 0x89, 0xbf, 0xe2, 0xcf, 0x9a, 0xdd, 0x16, 0x31, 0x9a, 0x78, 0xdb, 0xf7, 0xe6,
	0xbd, 0x79, 0x33, 0xb3, 0xd0, 0x5c, 0xe6, 0xe9, 0xfb, 0x36, 0x7c, 0xcd, 0x33, 0x9d, 0xa1, 0x67,
	0x01, 0xfd, 0x00, 0x48, 0x78, 0xcc, 0xe5, 0xdb, 0x41, 0x2a, 0x8d, 0x04, 0xaa, 0x09, 0x8f, 0x3b,
	0x6e, 0xd7, 0xed, 0x05, 0xdc, 0x3c, 0xf1, 0x06, 0x3c, 0xa5, 0x53, 0x2d, 0x3b, 0x95, 0xae, 0xdb,
	0x6b, 0xf5, 0x2f, 0xc2, 0xa2, 0xc7, 0xc9, 0x13, 0x2e, 0xb3, 0xdd, 0x2e, 0xdd, 0xaf, 0x78, 0xa1,
	0xa3, 0xd7, 0x50, 0x2f, 0x19, 0x0c, 0xc0, 0x13, 0x8b, 0x21, 0x5f, 0x10, 0x07, 0x1b, 0x50, 0x13,
	0x8b, 0xd9, 0x9c, 0xb8, 0x86, 0x1c, 0x3d, 0x44, 0xa3, 0x29, 0xa9, 0xd0, 0x4f, 0x17, 0x1a, 0x09,
	0x8f, 0x85, 0xf1, 0x61, 0x08, 0xbe, 0x69, 0x70, 0x50, 0x36, 0xbd, 0xd5, 0x6f, 0x9f, 0x92, 0xac,
	0x20, 0x14, 0xb6, 0xca, 0x4b, 0x15, 0x76, 0xa0, 0xfe, 0x28, 0x95, 0x4a, 0xd7, 0xc5, 0x68, 0x01,
	0x3f, 0x42, 0x1a, 0x81, 0x5f, 0x68, 0xb1, 0x09, 0x75, 0x93, 0x3a, 0x8f, 0xc6, 0xc4, 0x31, 0x80,
	0x27, 0x8c, 0x4d, 0xd8, 0x3d, 0x71, 0xcd, 0x3c, 0xe3, 0x19, 0x8b, 0x48, 0xc5, 0xd0, 0x09, 0x9b,
	0xb2, 0xd9, 0x13, 0x23, 0x55, 0x04, 0xf0, 0xef, 0x86, 0x93, 0x38, 0x1a, 0x93, 0x1a, 0x7d, 0x86,
	0x86, 0xd8, 0x68, 0xc9, 0xb2, 0x95, 0x34, 0x61, 0x6a, 0xa3, 0xe5, 0xe9, 0x36, 0x47, 0x88, 0x57,
	0x00, 0x3a, 0x97, 0x52, 0xe8, 0x7c, 0xb3, 0x5f, 0x97, 0x93, 0xfc, 0x60, 0xb0, 0xfd, 0xbd, 0x56,
	0xd5, 0xd6, 0x4a, 0xd4, 0xcf, 0xc0, 0x1b, 0x99, 0xfd, 0xf0, 0x16, 0x02, 0xfb, 0x30, 0x59, 0x78,
	0xfe, 0xe7, 0xbc, 0x97, 0x67, 0xbf, 0xee, 0x40, 0x1d, 0x1c, 0x40, 0xd3, 0x5a, 0xb8, 0x54, 0x87,
	0xad, 0xfe, 0xcf, 0x74, 0x5c, 0x80, 0x3a, 0x2f, 0xbe, 0xfd, 0xf6, 0xc1, 0x57, 0x00, 0x00, 0x00,
	0xff, 0xff, 0xef, 0xc4, 0x5f, 0xcd, 0x05, 0x02, 0x00, 0x00,
}
